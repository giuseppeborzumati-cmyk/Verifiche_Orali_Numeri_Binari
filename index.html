<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generatore Verifiche Informatica - Borzumati (Avanzato)</title>
    <!-- Carica Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Inter:wght@400;700;900&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .code-font { font-family: 'Roboto Mono', monospace; }
        .code-block { background-color: #1e293b; color: #f8fafc; padding: 0.75rem; border-radius: 0.5rem; overflow-x: auto; }

        /* Stili per la stampa PDF (ottimizzazione 2 pagine A4) */
        @media print {
            body { font-family: sans-serif !important; font-size: 10pt; background: white !important; }
            body > *:not(.print-container) { display: none !important; }
            .print-container { 
                display: block !important; 
                max-width: none !important; 
                margin: 0 !important; 
                padding: 0 !important; 
                box-shadow: none !important; 
                height: auto;
            }
            @page { margin: 1cm; }
            
            .print-header { border-bottom: 2px solid #6366f1; padding-bottom: 0.5rem; margin-bottom: 1rem; }
            .print-header h1 { font-size: 14pt !important; font-weight: bold; }
            .print-header p { font-size: 9pt !important; color: #374151; }
            
            .question-item { 
                margin-bottom: 1.2rem; 
                page-break-inside: avoid;
                border-left: 3px solid #6366f1;
                padding-left: 0.5rem;
            }
            .question-text { font-weight: 700; color: #1f2937; margin-bottom: 0.3rem; }
            .answer-line { 
                height: 1.2em; 
                display: block; 
                border-bottom: 1px dashed #9ca3af; 
                width: 100%; 
                margin-top: 0.2rem; 
            }
            .solution-box { 
                border: 1px solid #10b981; 
                background-color: #d1fae5; 
                padding: 0.2rem 0.5rem; 
                border-radius: 4px; 
                margin-top: 0.4rem; 
                font-size: 9pt;
            }
        }

        /* Stili per i pulsanti animati */
        .action-button { transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); font-weight: 700; position: relative; overflow: hidden; }
        .action-button:hover { transform: translateY(-3px); box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3); }
        .action-button::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.2); transform: skewX(-20deg); transition: all 0.7s; }
        .action-button:hover::before { left: 100%; }
        .bg-gradient-blue { background-image: linear-gradient(to right, #4c66ff 0%, #00c6ff 100%); }
        .bg-gradient-green { background-image: linear-gradient(to right, #10b981 0%, #1d7c4c 100%); }
    </style>
</head>
<body class="bg-gray-900 min-h-screen p-4 sm:p-8">

    <!-- Area di caricamento -->
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-90 z-50 flex items-center justify-center hidden">
        <div class="text-center text-white">
            <svg class="animate-spin h-10 w-10 text-indigo-400 mx-auto mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="text-lg font-semibold">Caricamento dati in corso... (Connessione a Firebase)</p>
        </div>
    </div>
    
    <!-- Sezione Dati Studente/Docente e Introduzione -->
    <div id="main-view" class="w-full max-w-7xl mx-auto bg-white rounded-xl shadow-[0_25px_50px_-12px_rgba(0,0,0,0.5)] p-6 sm:p-12 mb-8 space-y-10">
        <header class="text-center pb-6 border-b-4 border-indigo-500">
            <h1 class="text-4xl sm:text-6xl font-black leading-tight">
                <span class="bg-clip-text text-transparent bg-gradient-to-r from-blue-700 to-purple-600"> GENERATORE VERIFICHE INFORMATICA </span>
            </h1>
            <p class="text-xl text-gray-700 mt-2">Prof. Giuseppe Borzumati | Argomenti: Sistemi di Numerazione & Networking</p>
        </header>

        <!-- Dati Studente per la Generazione (Globali) -->
        <div class="bg-indigo-50 p-8 rounded-2xl shadow-inner border border-indigo-200">
            <h2 class="text-2xl font-bold text-indigo-800 mb-5 flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-7 h-7 mr-2 text-indigo-600">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 6a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0ZM4.501 20.118a7.5 7.5 0 0 1 14.998 0A17.933 17.933 0 0 1 12 21.75c-2.676 0-5.216-.584-7.499-1.632Z" />
                </svg> 
                Dati Base
                <span id="teacher-id" class="code-font text-xs ml-4 p-1 bg-indigo-200 text-indigo-800 rounded"></span>
            </h2>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
                <div> <input type="text" id="nome-studente" placeholder="Nome" class="p-4 border-2 border-indigo-300 rounded-xl w-full focus:ring-indigo-500 focus:border-indigo-500 text-lg"> </div>
                <div> <input type="text" id="cognome-studente" placeholder="Cognome" class="p-4 border-2 border-indigo-300 rounded-xl w-full focus:ring-indigo-500 focus:border-indigo-500 text-lg"> </div>
                <div> <input type="text" id="classe-studente" placeholder="Classe (es. 4B)" class="p-4 border-2 border-indigo-300 rounded-xl w-full focus:ring-indigo-500 focus:border-indigo-500 text-lg"> </div>
                <div> <input type="date" id="data-verifica" value="" class="p-4 border-2 border-indigo-300 rounded-xl w-full focus:ring-indigo-500 focus:border-indigo-500 text-lg"> </div>
            </div>
            <p class="text-sm text-indigo-600 mt-4 font-semibold">Tutti i campi sono obbligatori per generare il link di correzione.</p>
        </div>

        <!-- Contenitore delle Verifiche (4 Blocchi) -->
        <div class="space-y-12">

            <!-- BLOCCO 1: Verifiche Numeriche PURE -->
            <div id="blocco-verifica-a" class="p-8 bg-red-50 border-t-8 border-t-red-500 rounded-2xl shadow-3xl">
                <h3 class="text-3xl font-bold text-red-700 mb-4 flex items-center">
                    <span class="mr-3 text-4xl">üî¢</span> VERIFICA A: Base, Frazioni Binarie & Operazioni (10 Esercizi)
                </h3>
                <p class="text-gray-600 mb-6">Tracce: Individuazione Base Ingannatrice, Numeri Romani, Conversioni Miste Complesse, Addizione e Frazioni Binarie.</p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <button class="flex-1 action-button bg-gradient-blue text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('A', true)"> üìÑ Genera PDF Alunno </button>
                    <button class="flex-1 action-button bg-gradient-green text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('A', false)"> üéì Genera PDF Docente (Soluzioni) </button>
                </div>
                <div id="link-container-A" class="mt-6 space-y-3">
                    <h4 class="text-lg font-semibold text-red-600 border-b border-red-300 pb-1">Link di Correzione Generati (Verifica A):</h4>
                    <p class="text-sm text-gray-500" id="link-message-A">Nessuna verifica di Tipo A generata.</p>
                </div>
            </div>

            <!-- BLOCCO 2: Subnetting Semplice + Conversioni Miste -->
            <div id="blocco-verifica-b" class="p-8 bg-purple-50 border-t-8 border-t-purple-500 rounded-2xl shadow-3xl">
                <h3 class="text-3xl font-bold text-purple-700 mb-4 flex items-center">
                    <span class="mr-3 text-4xl">üåê</span> VERIFICA B: Networking Semplice & Conversioni (10 Esercizi)
                </h3>
                <p class="text-gray-600 mb-6">Tracce: Subnetting Veloce e Avanzato (max 2 IP), mix di Conversioni Complesse e Teoria (Differenza Base/Sottrazione).</p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <button class="flex-1 action-button bg-gradient-blue text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('B', true)"> üìÑ Genera PDF Alunno </button>
                    <button class="flex-1 action-button bg-gradient-green text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('B', false)"> üéì Genera PDF Docente (Soluzioni) </button>
                </div>
                <div id="link-container-B" class="mt-6 space-y-3">
                    <h4 class="text-lg font-semibold text-purple-600 border-b border-purple-300 pb-1">Link di Correzione Generati (Verifica B):</h4>
                    <p class="text-sm text-gray-500" id="link-message-B">Nessuna verifica di Tipo B generata.</p>
                </div>
            </div>

            <!-- BLOCCO 3: Complemento a Due, Floating Point e IP Avanzato -->
            <div id="blocco-verifica-c" class="p-8 bg-teal-50 border-t-8 border-t-teal-500 rounded-2xl shadow-3xl">
                <h3 class="text-3xl font-bold text-teal-700 mb-4 flex items-center">
                    <span class="mr-3 text-4xl">üî¨</span> VERIFICA C: Complemento a Due, Floating Point e IP (10 Esercizi)
                </h3>
                <p class="text-gray-600 mb-6">Tracce: Complemento a Due (8 bit) con teoria, Notazione Floating Point con teoria precisione, e Subnetting Avanzato.</p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <button class="flex-1 action-button bg-gradient-blue text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('C', true)"> üìÑ Genera PDF Alunno </button>
                    <button class="flex-1 action-button bg-gradient-green text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('C', false)"> üéì Genera PDF Docente (Soluzioni) </button>
                </div>
                <div id="link-container-C" class="mt-6 space-y-3">
                    <h4 class="text-lg font-semibold text-teal-600 border-b border-teal-300 pb-1">Link di Correzione Generati (Verifica C):</h4>
                    <p class="text-sm text-gray-500" id="link-message-C">Nessuna verifica di Tipo C generata.</p>
                </div>
            </div>
            
            <!-- BLOCCO 4: Riepilogo Completo e Problemi Critici (Verifica D) -->
            <div id="blocco-verifica-d" class="p-8 bg-yellow-50 border-t-8 border-t-yellow-500 rounded-2xl shadow-3xl">
                <h3 class="text-3xl font-bold text-yellow-800 mb-4 flex items-center">
                    <span class="mr-3 text-4xl">‚≠ê</span> VERIFICA D: Riepilogo Completo & Problemi Critici (10 Esercizi)
                </h3>
                <p class="text-gray-600 mb-6">Tracce: Mix bilanciato e complesso di tutti gli argomenti (C2, FP, Subnetting, Conversioni Ingannatrici) per una prova completa.</p>
                <div class="flex flex-col sm:flex-row gap-4">
                    <button class="flex-1 action-button bg-gradient-blue text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('D', true)"> üìÑ Genera PDF Alunno </button>
                    <button class="flex-1 action-button bg-gradient-green text-white py-4 px-8 rounded-xl text-xl" onclick="handleGeneration('D', false)"> üéì Genera PDF Docente (Soluzioni) </button>
                </div>
                <div id="link-container-D" class="mt-6 space-y-3">
                    <h4 class="text-lg font-semibold text-yellow-600 border-b border-yellow-300 pb-1">Link di Correzione Generati (Verifica D):</h4>
                    <p class="text-sm text-gray-500" id="link-message-D">Nessuna verifica di Tipo D generata.</p>
                </div>
            </div>

        </div>

        <footer class="text-center pt-8 text-gray-500 text-sm border-t border-gray-200">
            <p>Sistema di Generazione Verifiche v5.1 | Per l'Insegnante Giuseppe Borzumati. Assicurati che il pop-up del browser sia consentito per scaricare il PDF.</p>
        </footer>
    </div>

    <!-- VISTA DI CORREZIONE (Caricata tramite link condivisibile) -->
    <div id="correction-view" class="hidden w-full max-w-5xl mx-auto bg-white rounded-xl shadow-2xl p-6 sm:p-10 mb-8 space-y-8">
        <header class="text-center pb-4 border-b-4 border-green-500">
            <h1 class="text-4xl font-extrabold text-green-700 leading-tight">Griglia di Correzione Interattiva</h1>
            <p class="text-lg text-gray-600 mt-1">
                Studente: <span id="corr-student-name" class="font-extrabold text-indigo-600"></span> - 
                Classe: <span id="corr-class" class="font-extrabold text-indigo-600"></span> - 
                Verifica <span id="corr-title" class="font-bold"></span>
            </p>
        </header>

        <!-- Tabella Punteggio e Voto -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 bg-yellow-50 p-6 rounded-xl border-2 border-yellow-300 shadow-lg">
            <div class="col-span-1 lg:col-span-3">
                <h2 class="text-2xl font-bold text-yellow-800 mb-2 border-b border-yellow-400 pb-1">Valutazione</h2>
            </div>
            
            <div class="bg-blue-100 p-4 rounded-lg shadow-md">
                <p class="text-sm font-semibold text-blue-800">Punti Ottenuti:</p>
                <p class="text-4xl font-extrabold text-blue-600 mt-1"><span id="corr-points">0</span> / <span id="corr-max-points">10</span></p>
            </div>
            
            <div class="bg-purple-100 p-4 rounded-lg shadow-md">
                <p class="text-sm font-semibold text-purple-800">Voto Orale (Base 10):</p>
                <input type="number" id="voto-orale" min="0" max="10" step="0.1" value="6.0" onchange="updateFinalGrade()" class="p-2 border-2 border-purple-500 rounded-lg w-full mt-1 text-xl font-bold">
            </div>
            
            <div class="bg-red-100 p-4 rounded-lg shadow-md">
                <p class="text-sm font-semibold text-red-800">Voto Finale (Arrotondato per Difetto):</p>
                <p class="text-4xl font-extrabold text-red-600 mt-1"><span id="corr-grade-floored">0</span> / 10</p>
            </div>
            
            <div class="col-span-1 lg:col-span-3 bg-gray-100 p-4 rounded-lg border border-gray-300" id="conversion-explanation">
                <p class="text-sm font-bold text-gray-700">Formula di Calcolo:</p>
                <code class="code-font text-xs block mt-1 p-2 bg-white rounded"> Voto Scritto Base 10 = (Punti Ottenuti / 10) * 10 = <span id="voto-scritto-base">0.00</span> </code>
                <code class="code-font text-xs block mt-1 p-2 bg-white rounded"> Voto Finale = (Voto Scritto * 0.7) + (Voto Orale * 0.3) </code>
            </div>
        </div>

        <!-- Esercizi con Correzione -->
        <div id="correction-form" class="space-y-6"> 
            <!-- Gli esercizi e i campi di input saranno popolati qui dal JS -->
        </div>

        <button class="action-button bg-gradient-blue text-white py-4 px-8 rounded-xl text-lg mt-8 w-full" onclick="saveAndDownloadResultsPDF()"> Salva Risultati e Scarica PDF dei Commenti </button>
        <button class="action-button bg-gray-400 hover:bg-gray-500 text-gray-900 py-3 px-6 rounded-lg text-lg w-full" onclick="window.location.href = window.location.origin + window.location.pathname"> Torna alla Generazione Verifiche </button>
    </div>

    <!-- Contenitore Nascosto per la Stampa PDF (Stile ottimizzato per PDF) -->
    <div id="print-area" class="print-container hidden"></div>

    <!-- Firebase SDK Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, getDoc, query, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Variabili Globali del Modulo
        window.db = null;
        window.auth = null;
        window.teacherId = null;
        window.MAX_POINTS = 10; // Punti massimi per la verifica (max 11 esercizi richiesti)

        // Configurazione Firebase fornita dall'utente
        const firebaseConfig = {
            apiKey: "AIzaSyDtruKdnoFjMqob-1zf-Zw0hXn8j_YwVio",
            authDomain: "verifichenumeribinari.firebaseapp.com",
            projectId: "verifichenumeribinari",
            storageBucket: "verifichenumeribinari.firebasestorage.app",
            messagingSenderId: "648812468179",
            appId: "1:648812468179:web:1a0e2d65cb1aae28e60126",
            measurementId: "G-K5SL1808G4"
        };

        // Funzione di Inizializzazione Firebase
        async function initializeFirebase() {
            try {
                // 1. Inizializzazione App
                const app = initializeApp(firebaseConfig);
                window.db = getFirestore(app);
                window.auth = getAuth(app);

                // 2. Autenticazione Anonima
                await signInAnonymously(window.auth);
                window.teacherId = window.auth.currentUser.uid;
                
                // 3. Nascondi Overlay e Avvia l'app
                document.getElementById('loading-overlay').classList.add('hidden');
                document.getElementById('teacher-id').textContent = `Docente ID: ${window.teacherId.substring(0, 8)}...`;

                // 4. Carica i link di correzione esistenti
                await window.updateLinkContainers();

                // 5. Verifica se √® una vista di correzione
                const urlParams = new URLSearchParams(window.location.search);
                const examId = urlParams.get('examId');
                if (examId) {
                    window.showLoading();
                    await window.loadCorrectionView(examId);
                } else {
                    window.showMainView();
                }

            } catch (error) {
                console.error("Errore fatale nell'inizializzazione di Firebase e Auth:", error);
                document.getElementById('loading-overlay').classList.add('hidden');
                alert("Errore di connessione al database. Controlla la console per i dettagli.");
            }
        }

        // ESPORTA LE FUNZIONI DI FIRESTORE NEL CONTESTO GLOBALE
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.doc = doc;
        window.collection = collection;
        window.query = query;
        window.where = where;
        window.getDocs = getDocs;

        // Esegui l'inizializzazione al caricamento
        window.addEventListener('load', () => {
            initializeFirebase();
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('data-verifica').value = today;
        });
    </script>
    
    <script>
        // -------------------------------------------------------------------------
        // LOGICA DI VISTA E UTILITY (Indipendente da Moduli/Firebase)
        // -------------------------------------------------------------------------

        let currentExamData = null; // Dati della verifica attualmente in correzione
        
        window.showLoading = () => document.getElementById('loading-overlay').classList.remove('hidden');
        window.hideLoading = () => document.getElementById('loading-overlay').classList.add('hidden');

        // Navigazione tra le viste
        window.showMainView = () => {
            document.getElementById('main-view').classList.remove('hidden');
            document.getElementById('correction-view').classList.add('hidden');
            window.hideLoading();
        };

        window.loadCorrectionView = async (examId) => {
            window.showLoading();
            try {
                // Recupero il doc in "exams/{examId}"
                const examRef = window.doc(window.db, "exams", examId);
                const docSnap = await window.getDoc(examRef);
                
                if (docSnap.exists()) {
                    currentExamData = docSnap.data();
                    document.getElementById('main-view').classList.add('hidden');
                    document.getElementById('correction-view').classList.remove('hidden');
                    renderCorrectionForm(currentExamData);
                    updateFinalGrade(); // Calcola il voto iniziale
                } else {
                    alert("Verifica non trovata o ID non valido.");
                    window.location.href = window.location.origin + window.location.pathname; // Torna alla home
                }
            } catch (error) {
                console.error("Errore nel caricamento della correzione:", error);
                alert("Errore nel caricamento del documento dal database.");
                window.location.href = window.location.origin + window.location.pathname; // Torna alla home
            } finally {
                window.hideLoading();
            }
        };

        // Funzione per generare un ID unico
        const generateUniqueID = () => Date.now().toString(36) + Math.random().toString(36).substring(2, 5);

        // Funzione per pulire e standardizzare le risposte (tolleranza)
        const cleanAnswer = (s) => s.toString()
            .trim()
            .toUpperCase()
            .replace(/[^A-Z0-9\.\/\;\-\+\s]/g, '') // Rimuove caratteri non validi
            .replace(/\s+/g, ''); // Rimuove tutti gli spazi

        // -------------------------------------------------------------------------
        // FUNZIONI NUMERICHE DI CALCOLO (CRITICHE)
        // -------------------------------------------------------------------------
        
        // Conversione Decimale a Romano (fino a 999)
        function decToRoman(num) {
            const map = { 1000: 'M', 900: 'CM', 500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I' };
            let roman = '';
            for (let i of Object.keys(map).map(Number).sort((a, b) => b - a)) {
                while (num >= i) {
                    roman += map[i];
                    num -= i;
                }
            }
            return roman;
        }

        // Funzione per calcolare il Complemento a Due (8 bit)
        function toTwosComplement(num) {
            if (num >= 0) {
                return num.toString(2).padStart(8, '0');
            }
            
            // Per i numeri negativi:
            const absNum = Math.abs(num);
            let bin = absNum.toString(2).padStart(8, '0');
            
            // 1. Inverti i bit
            let inverted = [...bin].map(b => b === '0' ? '1' : '0').join('');
            
            // 2. Aggiungi 1 (in binario)
            let carry = 1;
            let twosComp = '';
            for (let i = 7; i >= 0; i--) {
                let bit = parseInt(inverted[i], 10);
                let sum = bit + carry;
                twosComp = (sum % 2) + twosComp;
                carry = Math.floor(sum / 2);
            }
            return twosComp;
        }
        
        // Calcolo Notazione Scientifica Binaria (Floating Point Semplificato)
        // Lavoriamo con 1 bit di Segno, 5 bit di Esponente (bias 15), 10 bit di Mantissa (bit nascosto)
        function calculateFloatingPoint(dec) {
            const sign = dec < 0 ? '1' : '0';
            let num = Math.abs(dec);
            
            if (num === 0) return { sign, exponent: '00000', mantissa: '0000000000' };

            // 1. Converti in Binario
            let intPart = Math.floor(num);
            let fracPart = num - intPart;
            
            let binary = intPart.toString(2) + '.';
            
            // 10 cifre frazionarie di precisione
            for (let i = 0; i < 15; i++) {
                fracPart *= 2;
                const bit = Math.floor(fracPart);
                binary += bit;
                fracPart -= bit;
            }
            
            // 2. Normalizzazione
            let exponent;
            let mantissa;
            
            const pointIndex = binary.indexOf('.');
            const firstOneIndex = binary.indexOf('1');

            if (intPart >= 1) { // Caso 1.xxxx
                exponent = pointIndex - 1;
                mantissa = binary.substring(pointIndex + 1);
                
                // Rimuove il bit intero (il '1' nascosto) e la virgola
                const normalizedString = binary.substring(firstOneIndex + 1).replace('.', '');
                mantissa = normalizedString;

            } else { // Caso 0.xxxx
                // 0.00101 -> 1.01 * 2^-3
                let nonZeroIndex = binary.substring(pointIndex + 1).indexOf('1');
                if (nonZeroIndex === -1) { // 0 o quasi 0
                    exponent = -100; // Valore piccolo
                } else {
                    exponent = -(nonZeroIndex + 1);
                }
                
                // Sposta la virgola dopo il primo 1 e prende la parte frazionaria
                const normalizedString = binary.substring(pointIndex + nonZeroIndex + 2);
                mantissa = normalizedString;
            }
            
            // 3. Esponente con Bias (Bias = 15)
            const biasedExponent = exponent + 15;
            const expBin = biasedExponent.toString(2).padStart(5, '0');
            
            // 4. Mantissa (Troncata a 10 bit)
            mantissa = mantissa.replace('.', '').substring(0, 10).padEnd(10, '0');
            
            // Output semplificato: Segno | Esponente (con bias) | Mantissa (senza 1 nascosto)
            return { sign, exponent: expBin, mantissa };
        }

        // Funzione per calcolare ID Rete/Broadcast
        function calculateNetworkIDs(ip, mask) {
            const octets = ip.split('.').map(o => parseInt(o));
            const ipBin = octets.map(o => o.toString(2).padStart(8, '0')).join('');
            
            const networkPart = ipBin.substring(0, mask);
            
            // Network ID (host part = 0)
            const netIDBinary = networkPart.padEnd(32, '0');
            let networkID = [];
            for (let n = 0; n < 4; n++) {
                networkID.push(parseInt(netIDBinary.substring(n * 8, n * 8 + 8), 2));
            }
            const netID = networkID.join('.');

            // Broadcast ID (host part = 1)
            const hostPart = '1'.repeat(32 - mask);
            const broadcastBinary = networkPart + hostPart;
            let broadcastID = [];
            for (let n = 0; n < 4; n++) {
                broadcastID.push(parseInt(broadcastBinary.substring(n * 8, n * 8 + 8), 2));
            }
            const bcastID = broadcastID.join('.');
            
            return { 
                network: `${netID}/${mask}`, 
                broadcast: `${bcastID}/${mask}`,
                firstHost: broadcastID.map((o, i) => i === 3 ? (o - (32-mask) > 0 ? o - (32-mask) : o) : o).join('.'), // semplificato per non generare
                totalHosts: Math.pow(2, (32 - mask)) - 2
            };
        }
        
        // -------------------------------------------------------------------------
        // LOGICA DI GENERAZIONE ESERCIZI AVANZATI (INGANNEVOLI)
        // -------------------------------------------------------------------------
        
        function generateTrickyConversion(from, to, min, max, allowZeroPrefix = false) {
            const baseFrom = from;
            const baseTo = to;
            let numDec = Math.floor(Math.random() * (max - min)) + min;

            // Rendi il numero "ingannevole" con 0 iniziali o cifre al limite
            if (baseFrom === 2 && numDec < 1000) {
                 numDec = Math.floor(Math.random() * (1024 - 512)) + 512; // Almeno 10 bit
            }
            
            let numInput;
            if (baseFrom === 10) numInput = numDec;
            else if (baseFrom === 2) numInput = numDec.toString(2).padStart(Math.ceil(Math.log2(numDec) / 4) * 4, allowZeroPrefix ? '0' : ''); // Blocchi di 4 bit
            else if (baseFrom === 8) numInput = numDec.toString(8);
            else if (baseFrom === 16) numInput = numDec.toString(16).toUpperCase();

            // Aggiunge zeri iniziali per rendere la conversione Bin->Hex/Octal pi√π difficile
            if (baseFrom === 2 && numDec > 2000 && !allowZeroPrefix) {
                numInput = numDec.toString(2).padStart(16, '0');
            }
            
            let solution;
            if (baseTo === 10) solution = numDec.toString();
            else if (baseTo === 2) solution = numDec.toString(2);
            else if (baseTo === 8) solution = numDec.toString(8);
            else if (baseTo === 16) solution = numDec.toString(16).toUpperCase();

            const labelFrom = baseFrom === 10 ? "Decimale (base 10)" : baseFrom === 2 ? "Binario (base 2)" : baseFrom === 8 ? "Ottale (base 8)" : "Esadecimale (base 16)";
            const labelTo = baseTo === 10 ? "DECIMALE (base 10)" : baseTo === 2 ? "BINARIO (base 2)" : baseTo === 8 ? "OTTALE (base 8)" : "ESADECIMALE (base 16)";
            
            const questionText = `CONVERTI il numero ${labelFrom}: **${numInput}** in ${labelTo}.`;
            return { type: 'conversion', text: questionText, base: baseTo, correct: solution, complexity: 'Alta' };
        }

        function generateBinaryFractionalQuestion() {
            // Parte intera da 6 a 12
            const intPart = Math.floor(Math.random() * 7) + 6; 
            // Parte frazionaria da 5 a 7 bit
            const fracBits = Math.floor(Math.random() * 3) + 5;

            let fractionalValue = 0;
            let binFractional = '';
            let tempFrac = Math.random(); 
            
            for (let i = 0; i < fracBits; i++) {
                tempFrac *= 2;
                let bit = Math.floor(tempFrac);
                binFractional += bit;
                fractionalValue += bit * Math.pow(2, -(i + 1));
                tempFrac -= bit;
            }

            const decimalValue = intPart + fractionalValue;
            const binaryValue = intPart.toString(2) + '.' + binFractional;
            const solution = decimalValue.toFixed(4); 

            const questionText = `Dato il numero binario con la virgola **${binaryValue}**, calcola il suo equivalente in Base DECIMALE. Fornisci il risultato con **quattro** cifre decimali, separatore decimale **punto** (es. 12.3456).`;
            return { type: 'fractional', text: questionText, correct: solution };
        }
        
        function generateTwosComplementQuestion() {
            const num = - (Math.floor(Math.random() * 126) + 1); // Numero negativo tra -1 e -127
            const solution = toTwosComplement(num);
            
            const questionText = `Rappresenta il numero decimale **${num}** in notazione Complemento a Due (8 bit). Successivamente, rispondi alla domanda: **"Qual √® il passo fondamentale che distingue l'operazione di SOTTRAZIONE dalla ADDZIONE, quando si usa il Complemento a Due?"**`;
            const theoryAnswer = `La sottrazione A - B in complemento a due viene eseguita sommando il minuendo A al complemento a due del sottraendo B, trascurando l'eventuale riporto finale. Il passo fondamentale √® quindi il calcolo del **Complemento a Due del sottraendo**.`;
            
            return { type: 'c2_theory', text: questionText, correct: `${solution}; ${theoryAnswer}` };
        }
        
        function generateFloatingPointQuestion() {
            const num = (Math.random() * 100) + 1; // Numero tra 1 e 101
            const signedNum = Math.random() < 0.5 ? num : -num;
            const { sign, exponent, mantissa } = calculateFloatingPoint(signedNum);
            
            const questionText = `Dato il valore decimale **${signedNum.toFixed(2)}**, calcola la sua rappresentazione in notazione Floating Point Semplificata (1 bit segno, 5 bit esponente con bias 15, 10 bit mantissa, bit nascosto '1'). Fornisci il risultato nel formato: **Segno;Esponente(Bias);Mantissa**. Successivamente, rispondi: **"Qual √® il limite intrinseco di precisione in questo tipo di rappresentazione?"**`;
            const theoryAnswer = `Il limite intrinseco √® dato dalla lunghezza fissa della **mantissa** (10 bit nel nostro caso), che impone un numero limitato di cifre significative al numero binario frazionario, causando un errore di **quantizzazione** o arrotondamento per i numeri che non sono potenze esatte di 2.`;
            
            return { type: 'fp_theory', text: questionText, correct: `${sign};${exponent};${mantissa}; ${theoryAnswer}` };
        }
        
        function generateSubnettingQuestion(advanced = false) {
            // Genera IP di Classe C (192.168.X.X)
            const octet3 = Math.floor(Math.random() * 254) + 1;
            const octet4 = Math.floor(Math.random() * 254) + 1;
            const ip = `192.168.${octet3}.${octet4}`;
            
            // Genera una maschera che richieda subnetting (tra /25 e /30)
            const mask = Math.floor(Math.random() * 6) + 25; 
            const ids = calculateNetworkIDs(ip, mask);
            
            let questionText, correctBase, correctSolution;

            if (!advanced) {
                // Networking Veloce (Classico)
                questionText = `Dato l'indirizzo IP **${ip}/${mask}** (CIDR), calcola l'indirizzo di **NETWORK ID** e l'indirizzo di **BROADCAST ID** per la sottorete a cui appartiene. Fornisci i risultati nel formato: **NetworkID;BroadcastID** (es. 192.168.1.0;192.168.1.255)`;
                correctSolution = `${ids.network.split('/')[0]};${ids.broadcast.split('/')[0]}`;
                correctBase = 'IP_SV';
            } else {
                // Networking Avanzato (Maschera Ingannevole)
                const numHosts = ids.totalHosts + 2;
                questionText = `L'indirizzo **${ip}** deve essere assegnato ad una sottorete che possa contenere almeno **${Math.ceil(numHosts * 1.5)}** host. Qual √® la **Maschera di Rete** (in notazione /CIDR) da utilizzare? Successivamente, indica il **primo indirizzo host assegnabile** di quella sottorete. Fornisci il risultato nel formato: **/CIDR;PrimoHost**`;
                
                // Ricalcolo la CIDR necessaria (per ingannare)
                let requiredHosts = Math.ceil(numHosts * 1.5);
                let bits = 0;
                while (Math.pow(2, bits) - 2 < requiredHosts) {
                    bits++;
                }
                const newMask = 32 - bits;
                const newIDs = calculateNetworkIDs(ip, newMask);
                const firstHost = newIDs.network.split('.').slice(0, 3).join('.') + '.' + (parseInt(newIDs.network.split('.')[3]) + 1);

                correctSolution = `/${newMask};${firstHost}`;
                correctBase = 'IP_SA';
            }

            return { type: 'subnetting', text: questionText, correct: correctSolution, base: correctBase };
        }

        // -------------------------------------------------------------------------
        // FUNZIONE DI GENERAZIONE VERIFICA FINALE
        // -------------------------------------------------------------------------

        function generateExam(type) {
            const questions = [];
            const commonConversions = [
                { from: 10, to: 2, min: 100, max: 500, label: "Decimale ‚Üí Binario" },
                { from: 2, to: 16, min: 1000, max: 4096, label: "Binario ‚Üí Esadecimale (lungo)" },
                { from: 16, to: 8, min: 1000, max: 4096, label: "Esadecimale ‚Üí Ottale (multi-step)" }
            ];

            const complexConversions = [
                generateTrickyConversion(10, 2, 256, 1024),
                generateTrickyConversion(8, 16, 512, 4096, true), // Ottale -> Hex con zeri binari iniziali
                generateTrickyConversion(2, 10, 4000, 8000),
            ];

            // ---------------------------------------------------------------------
            // VERIFICA A: Base, Romani, Conversione & Frazioni (Totale 10 Esercizi)
            // ---------------------------------------------------------------------
            if (type === 'A') {
                // 1. Esercizio Inganno Base (Come richiesto)
                const trickyNum = Math.floor(Math.random() * 255) + 256; // Es. 312
                const baseOptions = [2, 8, 10, 16].filter(b => trickyNum.toString(b).length > 2); // Basi valide
                const baseFrom = baseOptions[Math.floor(Math.random() * baseOptions.length)];
                const numInput = trickyNum.toString(10);
                const solution = `${baseFrom};${trickyNum.toString(2)}`;
                questions.push({
                    type: 'base_detect',
                    text: `**(1 Pts) ESERCIZIO INGANNEVOLE:** INDIVIDUA la base di partenza (2, 8, 10 o 16) che rende valido il numero **${numInput}**. Successivamente, CONVERTI il numero in BINARIO (Base 2). Fornisci il risultato nel formato: **BasePartenza;Risultato** (es. 10;111011).`,
                    correct: solution
                });
                
                // 2. Numeri Romani (Come richiesto)
                const numDecRoman = Math.floor(Math.random() * 899) + 100; // tra 100 e 999
                questions.push({
                    type: 'romani',
                    text: `CONVERTI il numero Decimale **${numDecRoman}** nel sistema di numerazione **ROMANO**.`,
                    correct: decToRoman(numDecRoman)
                });
                
                // 3-6. Conversioni Complesse (4)
                questions.push(complexConversions[0]); // 10 -> 2 (Lungo)
                questions.push(complexConversions[1]); // 8 -> 16 (Ingannevole)
                questions.push(generateTrickyConversion(16, 10, 400, 1000)); // 16 -> 10 (Medio)
                questions.push(generateTrickyConversion(2, 8, 4096, 8192, true)); // 2 -> 8 (Lungo con zeri iniziali)

                // 7. Frazione Binaria
                questions.push(generateBinaryFractionalQuestion());
                
                // 8. Addizione Binaria Complicata (con riporto multiplo)
                const add1Dec = Math.floor(Math.random() * 100) + 100;
                const add2Dec = Math.floor(Math.random() * 100) + 100;
                const bin1 = add1Dec.toString(2).padStart(8, '0');
                const bin2 = add2Dec.toString(2).padStart(8, '0');
                questions.push({
                    type: 'bin_op',
                    text: `Esegui l'operazione di **ADDZIONE** binaria tra i numeri **${bin1} + ${bin2}**. Fornisci il risultato in Binario.`,
                    correct: (add1Dec + add2Dec).toString(2)
                });
                
                // 9-10. Teoria (Come richiesto)
                questions.push({ 
                    type: 'theory_general', 
                    text: `Come gestisci la conversione da una base $B$ (diversa da 10) a una base $C$ (diversa da 10), senza passare per la base 10? Descrivi il passo fondamentale e un esempio breve.`,
                    correct: 'MANUAL_GRADING' 
                });
                 questions.push({
                    type: 'theory_romani',
                    text: `Spiega la principale differenza tra il sistema numerico romano e il sistema posizionale in termini di rappresentazione e operazioni.`,
                    correct: 'MANUAL_GRADING' 
                });
            }

            // ---------------------------------------------------------------------
            // VERIFICA B: Networking Semplice & Conversioni (Totale 10 Esercizi)
            // ---------------------------------------------------------------------
            if (type === 'B') {
                // 1-4. Conversioni Complesse (4)
                questions.push(complexConversions[0]); // 10 -> 2
                questions.push(complexConversions[2]); // 2 -> 10
                questions.push(generateTrickyConversion(16, 2, 500, 1500)); // 16 -> 2 (Lungo)
                questions.push(generateTrickyConversion(8, 10, 300, 700)); // 8 -> 10 (Medio)
                
                // 5. Frazione Binaria
                questions.push(generateBinaryFractionalQuestion());

                // 6. Subnetting Veloce (1 IP)
                questions.push(generateSubnettingQuestion(false));

                // 7. Subnetting Avanzato (2¬∞ IP - Inganno Maschera)
                questions.push(generateSubnettingQuestion(true));
                
                // 8-10. Teoria
                questions.push({ 
                    type: 'theory_base', 
                    text: `Se devi convertire un numero in base 10, come puoi fare velocemente la conversione in Binario, Ottale ed Esadecimale? Qual √® il metodo fondamentale che non pu√≤ essere evitato?`,
                    correct: 'MANUAL_GRADING' 
                });
                questions.push({
                    type: 'theory_c2',
                    text: `Qual √® il valore massimo e minimo (incluso) che √® possibile rappresentare con **10 bit** utilizzando il Complemento a Due?`,
                    correct: 'MANUAL_GRADING' 
                });
                questions.push({ 
                    type: 'theory_ip', 
                    text: `Descrivi la funzione e la struttura di una **Maschera di Sottorete** e come essa distingue la porzione di Rete dalla porzione di Host.`,
                    correct: 'MANUAL_GRADING' 
                });
            }
            
            // ---------------------------------------------------------------------
            // VERIFICA C: Complemento a Due, Floating Point e IP Avanzato (Totale 10 Esercizi)
            // ---------------------------------------------------------------------
            if (type === 'C') {
                // 1. Conversione Complessa (8 -> 16)
                questions.push(complexConversions[1]); 
                // 2. Conversione Complessa (16 -> 2)
                questions.push(generateTrickyConversion(16, 2, 5000, 10000));
                
                // 3. Complemento a Due (con Teoria Sottrazione)
                questions.push(generateTwosComplementQuestion());
                
                // 4. Floating Point Semplificato (con Teoria Precisione)
                questions.push(generateFloatingPointQuestion());

                // 5. Conversione Frazionaria
                questions.push(generateBinaryFractionalQuestion());

                // 6. Esercizio Inganno Base
                const trickyNum = Math.floor(Math.random() * 255) + 500; 
                const baseFrom = [8, 16][Math.floor(Math.random() * 2)]; // 8 o 16
                const numInput = trickyNum.toString(10);
                const solution = `${baseFrom};${trickyNum.toString(baseFrom)}`;
                questions.push({
                    type: 'base_detect',
                    text: `**(1 Pts) ESERCIZIO CRITICO:** INDIVIDUA la base di partenza (8 o 16) che rende valido il numero **${numInput}** e CONVERTI in quella base. Fornisci il risultato nel formato: **BasePartenza;Risultato** (es. 8;760).`,
                    correct: solution
                });
                
                // 7. Subnetting Veloce (1 IP)
                questions.push(generateSubnettingQuestion(false));
                
                // 8. Subnetting Avanzato (2¬∞ IP - Inganno Maschera)
                questions.push(generateSubnettingQuestion(true));

                // 9-10. Teoria (Floating Point & Conversione)
                questions.push({ 
                    type: 'theory_fp', 
                    text: `Spiega il ruolo del **Bias** nell'esponente di un numero in Floating Point e come aiuta nella rappresentazione dei numeri molto piccoli.`,
                    correct: 'MANUAL_GRADING' 
                });
                 questions.push({ 
                    type: 'theory_conversion_rule', 
                    text: `Descrivi la "regola delle potenze" per la conversione da una base $B$ in base 10 (Decimale). In quale contesto si usa la divisione ripetuta per la base?`,
                    correct: 'MANUAL_GRADING' 
                });
            }

            // ---------------------------------------------------------------------
            // VERIFICA D: Riepilogo Completo e Critico (Totale 10 Esercizi)
            // ---------------------------------------------------------------------
            if (type === 'D') {
                // 1. Inganno Base
                questions.push(generateExam('A').find(q => q.type === 'base_detect'));

                // 2. Numeri Romani
                questions.push(generateExam('A').find(q => q.type === 'romani'));

                // 3. Conversione Frazionaria
                questions.push(generateBinaryFractionalQuestion());

                // 4. Complemento a Due
                questions.push(generateTwosComplementQuestion());

                // 5. Floating Point
                questions.push(generateFloatingPointQuestion());
                
                // 6. Conversione (2 -> 16)
                questions.push(generateTrickyConversion(2, 16, 5000, 10000, true)); 
                
                // 7. Conversione (10 -> 8)
                questions.push(generateTrickyConversion(10, 8, 500, 1000)); 

                // 8. Subnetting Veloce (1 IP)
                questions.push(generateSubnettingQuestion(false));

                // 9. Subnetting Avanzato (2¬∞ IP - Inganno Maschera)
                questions.push(generateSubnettingQuestion(true));

                // 10. Teoria (Combinata)
                questions.push({ 
                    type: 'theory_all', 
                    text: `Confronta la rappresentazione dei numeri reali in Frazione Binaria e in Floating Point. Quale delle due √® pi√π efficiente in termini di range e quale in termini di precisione?`,
                    correct: 'MANUAL_GRADING' 
                });
            }

            return questions;
        }

        // -------------------------------------------------------------------------
        // LOGICA UTILITY (Aggiornamento UI e PDF)
        // -------------------------------------------------------------------------
        
        window.updateFinalGrade = () => {
            if (!currentExamData) return;

            const maxPoints = window.MAX_POINTS;
            let earnedPoints = 0;
            const comments = [];

            // Calcola i punti guadagnati
            currentExamData.questions.forEach((q, index) => {
                const isChecked = document.getElementById(`q-${index}-correct`).checked;
                if (isChecked) {
                    earnedPoints += 1;
                }
                const comment = document.getElementById(`q-${index}-comment`).value;
                comments.push({ index, comment, isCorrect: isChecked });
            });
            
            // Aggiorna UI Punti
            document.getElementById('corr-points').textContent = earnedPoints;
            
            // Calcolo Voto Scritto
            const writtenGradeBase = (earnedPoints / maxPoints) * 10;
            document.getElementById('voto-scritto-base').textContent = writtenGradeBase.toFixed(2);

            // Calcolo Voto Finale (Media Ponderata 70/30)
            const oralGrade = parseFloat(document.getElementById('voto-orale').value) || 0;
            const finalGrade = (writtenGradeBase * 0.7) + (oralGrade * 0.3);

            // Aggiorna UI Voto Finale
            document.getElementById('corr-grade-floored').textContent = Math.floor(finalGrade);
            
            // Aggiorna l'oggetto per il salvataggio
            currentExamData.score = earnedPoints;
            currentExamData.comments = comments;
            currentExamData.writtenGrade = writtenGradeBase.toFixed(2);
            currentExamData.oralGrade = oralGrade;
            currentExamData.finalGrade = Math.floor(finalGrade);
        }

        function renderCorrectionForm(data) {
            document.getElementById('corr-student-name').textContent = `${data.studentName} ${data.studentSurname}`;
            document.getElementById('corr-class').textContent = data.studentClass;
            document.getElementById('corr-title').textContent = data.examType;
            document.getElementById('corr-max-points').textContent = window.MAX_POINTS;
            
            const formContainer = document.getElementById('correction-form');
            formContainer.innerHTML = '';
            
            data.questions.forEach((q, index) => {
                const isTheory = q.correct === 'MANUAL_GRADING';
                
                // Formatta la soluzione per la visualizzazione
                let solutionDisplay = q.correct.replace('MANUAL_GRADING', 'Valutazione manuale richiesta (Teoria)');
                if (q.type === 'c2_theory' || q.type === 'fp_theory') {
                    // Separa la soluzione numerica dalla teoria
                    const parts = q.correct.split(';');
                    solutionDisplay = `**Risultato Numerico:** ${parts[0]};${parts[1]};${parts[2] || ''}<br>**Risposta Teorica Attesa:** ${parts.slice(parts.length - 1).join(';')}`;
                }


                const item = document.createElement('div');
                item.className = 'bg-white p-5 rounded-xl shadow-lg border border-gray-200 question-item';
                item.innerHTML = `
                    <div class="flex justify-between items-start mb-2">
                        <p class="text-xl font-extrabold text-gray-800">Esercizio ${index + 1} (${q.type === 'base_detect' || q.type === 'c2_theory' || q.type === 'fp_theory' ? '2 Pts' : '1 Pt'})</p>
                        <label class="inline-flex items-center space-x-2 p-2 bg-green-100 rounded-lg">
                            <input type="checkbox" id="q-${index}-correct" class="form-checkbox h-6 w-6 text-green-600 rounded-full" onchange="updateFinalGrade()">
                            <span class="text-lg font-bold text-green-700">Punto Assegnato</span>
                        </label>
                    </div>
                    <p class="question-text text-lg mt-1 mb-3">${q.text}</p>
                    
                    <div class="solution-box">
                        <p class="font-bold text-teal-800">Soluzione (Docente):</p>
                        <code class="code-font text-sm block mt-1 text-teal-700">${solutionDisplay}</code>
                    </div>

                    <div class="mt-4">
                        <label for="q-${index}-comment" class="block text-sm font-medium text-gray-700">Commento / Valutazione Dettagliata:</label>
                        <textarea id="q-${index}-comment" rows="3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2 border">${data.comments ? data.comments[index].comment : ''}</textarea>
                    </div>
                `;
                formContainer.appendChild(item);
                
                // Imposta lo stato iniziale del checkbox se esistono commenti salvati
                if (data.comments && data.comments[index].isCorrect) {
                    document.getElementById(`q-${index}-correct`).checked = true;
                }
            });
            
            // Imposta il voto orale salvato se esiste
            if (data.oralGrade) {
                document.getElementById('voto-orale').value = data.oralGrade;
            }

            // Aggiungo la logica per aggiornare i max points in base ai 2 Pts
            const initialMaxPoints = data.questions.filter(q => q.type === 'base_detect' || q.type === 'c2_theory' || q.type === 'fp_theory').length * 2 + 
                                     data.questions.filter(q => !(q.type === 'base_detect' || q.type === 'c2_theory' || q.type === 'fp_theory')).length * 1;

            window.MAX_POINTS = initialMaxPoints;
            document.getElementById('corr-max-points').textContent = window.MAX_POINTS;
            document.getElementById('conversion-explanation').querySelector('code').innerHTML = `Voto Scritto Base 10 = (Punti Ottenuti / ${window.MAX_POINTS}) * 10 = <span id="voto-scritto-base">0.00</span>`;

            updateFinalGrade();
        }

        // -------------------------------------------------------------------------
        // FUNZIONI FIREBASE E PDF
        // -------------------------------------------------------------------------

        window.updateLinkContainers = async () => {
            if (!window.db || !window.teacherId) return;

            try {
                const examsRef = window.collection(window.db, "exams");
                const q = window.query(examsRef, window.where("teacherId", "==", window.teacherId));
                const querySnapshot = await window.getDocs(q);

                const links = { A: [], B: [], C: [], D: [] };

                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    const examId = doc.id;
                    const url = `${window.location.origin}${window.location.pathname}?examId=${examId}`;
                    links[data.examType].push({
                        id: examId,
                        url: url,
                        name: `${data.studentName} ${data.studentSurname} - ${data.studentClass}`
                    });
                });

                ['A', 'B', 'C', 'D'].forEach(type => {
                    const container = document.getElementById(`link-container-${type}`);
                    const messageElement = document.getElementById(`link-message-${type}`);
                    
                    if (links[type].length === 0) {
                        messageElement.textContent = `Nessuna verifica di Tipo ${type} generata.`;
                    } else {
                        messageElement.innerHTML = links[type].map(link => `
                            <div class="flex justify-between items-center text-sm p-2 bg-white rounded-lg shadow-sm">
                                <span class="font-medium text-gray-700">${link.name}</span>
                                <a href="${link.url}" target="_blank" class="text-blue-600 hover:text-blue-800 font-semibold underline ml-4">Apri Correzione</a>
                            </div>
                        `).join('');
                    }
                });

            } catch (e) {
                console.warn("Impossibile caricare i link di correzione:", e);
            }
        };

        window.handleGeneration = async (type, isStudentVersion) => {
            const studentName = document.getElementById('nome-studente').value.trim();
            const studentSurname = document.getElementById('cognome-studente').value.trim();
            const studentClass = document.getElementById('classe-studente').value.trim();
            const examDate = document.getElementById('data-verifica').value;

            if (!studentName || !studentSurname || !studentClass || !examDate) {
                alert("Per generare il PDF e il link di correzione, devi compilare tutti i campi (Nome, Cognome, Classe, Data).");
                return;
            }

            window.showLoading();
            
            try {
                const questions = generateExam(type);
                const examId = generateUniqueID();
                
                const examData = {
                    id: examId,
                    teacherId: window.teacherId,
                    studentName,
                    studentSurname,
                    studentClass,
                    examDate,
                    examType: type,
                    questions: questions,
                    score: 0,
                    oralGrade: 6.0,
                    finalGrade: 0,
                    comments: questions.map((q, index) => ({ 
                        index: index, 
                        comment: `Valutazione esercizio ${index + 1}.`, 
                        isCorrect: false 
                    }))
                };

                // 1. Salva i dati della verifica (Domande + Soluzioni) in Firestore
                const examRef = window.doc(window.db, "exams", examId);
                await window.setDoc(examRef, examData);

                // 2. Genera il PDF
                generatePDF(examData, isStudentVersion);
                
                // 3. Mostra il link di correzione se versione docente
                if (!isStudentVersion) {
                    await window.updateLinkContainers();
                }

            } catch (error) {
                console.error("Errore durante la generazione della verifica:", error);
                alert("Si √® verificato un errore durante il salvataggio o la generazione del PDF. Controlla la console.");
            } finally {
                window.hideLoading();
            }
        };

        function generatePDF(data, isStudentVersion) {
            const printArea = document.getElementById('print-area');
            printArea.innerHTML = ''; // Pulisci area di stampa
            
            const totalPoints = data.questions.filter(q => q.type === 'base_detect' || q.type === 'c2_theory' || q.type === 'fp_theory').length * 2 + 
                                data.questions.filter(q => !(q.type === 'base_detect' || q.type === 'c2_theory' || q.type === 'fp_theory')).length * 1;

            const solutionLink = `${window.location.origin}${window.location.pathname}?examId=${data.id}`;

            let htmlContent = `
                <div class="print-header">
                    <h1 class="text-2xl font-black text-center text-gray-900">VERIFICA DI INFORMATICA - ${data.examType}</h1>
                    <p class="text-xs text-center text-gray-500 mt-1">Sistemi di Numerazione, Floating Point, Complemento a Due e Networking (Max ${totalPoints} Punti)</p>
                    <div class="flex justify-between text-xs mt-3">
                        <p><strong>Docente:</strong> Prof. Borzumati</p>
                        <p><strong>Studente:</strong> ${data.studentName} ${data.studentSurname}</p>
                        <p><strong>Classe:</strong> ${data.studentClass}</p>
                        <p><strong>Data:</strong> ${new Date(data.examDate).toLocaleDateString('it-IT')}</p>
                    </div>
                </div>
                
                <div class="space-y-4">
            `;

            data.questions.forEach((q, index) => {
                const points = q.type === 'base_detect' || q.type === 'c2_theory' || q.type === 'fp_theory' ? '2 Pts' : '1 Pt';
                
                let solutionDisplay = '';
                if (!isStudentVersion) {
                    let correctText = q.correct.replace('MANUAL_GRADING', 'Valutazione Manuale: Risposta aperta richiesta.');
                    if (q.type.endsWith('_theory')) {
                        const parts = q.correct.split(';');
                        correctText = `**Risultato Atteso:** ${parts.slice(0, -1).join(';') || 'N/D'}<br>**Teoria Attesa:** ${parts.slice(-1)}`;
                    }

                    solutionDisplay = `<div class="solution-box">
                        <p class="font-bold text-teal-800">Soluzione e Istruzioni Correzione:</p>
                        <code class="code-font text-xs block mt-1 text-teal-700">${correctText}</code>
                    </div>`;
                }

                htmlContent += `
                    <div class="question-item">
                        <p class="question-text text-sm">**${index + 1}.** [${points}] ${q.text}</p>
                        ${solutionDisplay}
                        <span class="answer-line"></span>
                        <span class="answer-line"></span>
                        ${q.type.includes('theory') ? '<span class="answer-line"></span><span class="answer-line"></span>' : ''}
                    </div>
                `;
            });
            
            if (!isStudentVersion) {
                 htmlContent += `<div class="mt-8 p-4 bg-yellow-100 border border-yellow-300 rounded-lg text-xs">
                    <p class="font-bold text-yellow-800">LINK DI CORREZIONE INTERATTIVA (NON stamparlo in PDF Alunno):</p>
                    <code class="code-font break-all">${solutionLink}</code>
                </div>`;
            }

            htmlContent += `</div>`;

            printArea.innerHTML = htmlContent;
            window.print();
        }

        window.saveAndDownloadResultsPDF = async () => {
            if (!currentExamData) {
                alert("Nessuna verifica caricata per il salvataggio.");
                return;
            }

            window.showLoading();
            
            try {
                // Ricalcola i punti finali e aggiorna currentExamData
                updateFinalGrade(); 
                
                // 1. Salva i risultati in Firestore
                const examRef = window.doc(window.db, "exams", currentExamData.id);
                await window.setDoc(examRef, currentExamData, { merge: true }); // Aggiorna solo i campi score/comments/grade

                // 2. Genera il PDF dei commenti per la consegna
                generateFeedbackPDF(currentExamData);

            } catch (error) {
                console.error("Errore durante il salvataggio e download:", error);
                alert("Si √® verificato un errore durante il salvataggio dei risultati nel database. Controlla la console.");
            } finally {
                window.hideLoading();
            }
        }

        function generateFeedbackPDF(data) {
            const printArea = document.getElementById('print-area');
            printArea.innerHTML = ''; 
            
            let htmlContent = `
                <div class="print-header">
                    <h1 class="text-2xl font-black text-center text-green-700">FEEDBACK & VALUTAZIONE VERIFICA</h1>
                    <p class="text-xs text-center text-gray-500 mt-1">Dettaglio Punti e Commenti del Docente</p>
                    <div class="flex justify-between text-xs mt-3">
                        <p><strong>Studente:</strong> ${data.studentName} ${data.studentSurname}</p>
                        <p><strong>Classe:</strong> ${data.studentClass}</p>
                        <p><strong>Data:</strong> ${new Date(data.examDate).toLocaleDateString('it-IT')}</p>
                    </div>
                </div>
                
                <div class="space-y-6">
                    <div class="grid grid-cols-3 gap-4 text-sm font-bold text-white text-center">
                        <div class="bg-blue-600 p-2 rounded-lg">Punti Totali: ${window.MAX_POINTS}</div>
                        <div class="bg-green-600 p-2 rounded-lg">Punti Ottenuti: ${data.score}</div>
                        <div class="bg-red-600 p-2 rounded-lg">Voto Finale (Arrotondato): ${data.finalGrade} / 10</div>
                    </div>

                    <h2 class="text-lg font-bold text-gray-700 border-b pb-1">Dettaglio Esercizi:</h2>
            `;

            data.questions.forEach((q, index) => {
                const comment = data.comments.find(c => c.index === index) || { comment: 'Nessun commento.', isCorrect: false };
                const badgeClass = comment.isCorrect ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800';
                
                htmlContent += `
                    <div class="p-4 border-l-4 ${comment.isCorrect ? 'border-green-500' : 'border-red-500'} bg-gray-50 rounded-md question-item">
                        <div class="flex justify-between items-start">
                            <p class="font-semibold text-gray-800">Esercizio ${index + 1}: ${q.text}</p>
                            <span class="px-2 py-1 text-xs font-bold rounded ${badgeClass}">${comment.isCorrect ? 'CORRETTO (1 Pt)' : 'ERRATO (0 Pt)'}</span>
                        </div>
                        <div class="mt-2 text-sm">
                            <p class="font-bold text-gray-700">Commento Docente:</p>
                            <p class="text-gray-600 italic mt-1">${comment.comment || 'Nessun commento registrato.'}</p>
                        </div>
                    </div>
                `;
            });

            htmlContent += `</div>`;
            printArea.innerHTML = htmlContent;
            window.print();
        }

    </script>
</body>
</html>
